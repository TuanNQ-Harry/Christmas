<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>üéÑ Merry Christmas</title>

  <style>
    :root{
      --bg1:#03110c;
      --bg2:#082319;

      --text:#eaf7f0;
      --muted:#b8d7ca;
      --gold:#ffd36a;

      --uiGlass: rgba(0,0,0,.18);
      --uiBorder: rgba(255,255,255,.12);
      --textAlpha: .94;
      --imgAlpha: .98;

      --safeTop: env(safe-area-inset-top, 0px);
      --safeBottom: env(safe-area-inset-bottom, 0px);
      --safeLeft: env(safe-area-inset-left, 0px);
      --safeRight: env(safe-area-inset-right, 0px);
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial}
    body{
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(255,255,255,.06), transparent 55%),
        radial-gradient(900px 700px at 80% 20%, rgba(255,211,106,.10), transparent 55%),
        linear-gradient(140deg,var(--bg1),var(--bg2));
      overflow:hidden;
      overscroll-behavior:none;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }

    /* Canvases */
    canvas{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      pointer-events:none;
      user-select:none;
    }
    #sky{ z-index:0; }
    #snow{ z-index:5; } /* single snow layer = faster on iOS */

    /* HUD (kept minimal; safe-area aware) */
    .hud{
      position:fixed;
      left:50%;
      top: calc(var(--safeTop) + 12px);
      transform:translateX(-50%);
      z-index:10;

      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;

      padding:10px 12px;
      border-radius:999px;
      background: var(--uiGlass);
      border: 1px solid var(--uiBorder);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .title{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(234,247,240,.90);
      font-size:13px;
      user-select:none;
      white-space:nowrap;
    }
    .btn{
      cursor:pointer;
      padding:8px 12px;
      border-radius:999px;
      background:rgba(255,211,106,.12);
      border:1px solid rgba(255,211,106,.30);
      color:rgba(234,247,240,.95);
      font-weight:650;
      font-size:13px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.secondary{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
    }
    .btn:hover{filter:brightness(1.08)}
    .btn:active{transform:translateY(1px)}

    .slider{
      display:flex; align-items:center; gap:8px;
      padding:7px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      font-size:13px;
      color:rgba(184,215,202,.95);
      user-select:none;
    }
    input[type="range"]{width:110px}

    /* Scene */
    .scene{
      position:relative;
      z-index:6; /* below HUD; above sky */
      height:100%;
      display:grid;
      place-items:center;
      padding:
        calc(var(--safeTop) + 88px)
        calc(var(--safeRight) + 18px)
        calc(var(--safeBottom) + 18px)
        calc(var(--safeLeft) + 18px);
    }

    .capyWrap{
      position:relative;
      width:min(820px, 94vw);
      margin-inline:auto;
      isolation:isolate; /* keep blending sane */
    }

    .halo{
      position:absolute;
      inset:-10% -10% -10% -10%;
      z-index:0;
      background:
        radial-gradient(closest-side at 50% 35%, rgba(255,211,106,.14), transparent 62%),
        radial-gradient(closest-side at 35% 55%, rgba(255,255,255,.06), transparent 62%),
        radial-gradient(closest-side at 65% 65%, rgba(180,220,255,.05), transparent 62%);
      filter: blur(18px);
      opacity:.95;
      pointer-events:none;
    }

    .capy{
      position:relative;
      z-index:1;
      width:100%;
      height:auto;
      display:block;
      opacity: var(--imgAlpha);
      border-radius:22px;
      filter:
        drop-shadow(0 24px 65px rgba(0,0,0,.42))
        drop-shadow(0 0 34px rgba(255,240,210,.12));
      mix-blend-mode: screen; /* auto-disabled on iOS for perf via .ios */
    }

    /* Text overlay on top of image */
    .overlay{
      position:absolute;
      inset:0;
      z-index:2;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      text-align:center;

      padding: clamp(16px, 4.2vw, 44px) clamp(12px, 4vw, 40px);
      pointer-events:none;

      opacity: var(--textAlpha);

      background: linear-gradient(
        to bottom,
        rgba(0,0,0,.30),
        rgba(0,0,0,.12) 42%,
        rgba(0,0,0,0) 75%
      );
      border-radius:22px;
    }

    .headline{
      margin:0 0 10px 0;
      font-size: clamp(30px, 5.0vw, 58px);
      line-height:1.04;
      letter-spacing:-0.6px;

      background: linear-gradient(
        90deg,
        rgba(255,255,255,.96),
        rgba(255,211,106,.92),
        rgba(210,240,255,.92)
      );
      -webkit-background-clip:text;
      background-clip:text;
      color: transparent;

      text-shadow:
        0 3px 26px rgba(0,0,0,.55),
        0 0 36px rgba(255,240,210,.12);
    }

    .message{
      margin:0;
      max-width: 54ch;
      font-size: clamp(15px, 2.2vw, 19px);
      line-height:1.55;
      color: rgba(234,247,240,.96);
      white-space:pre-wrap;
      text-shadow:
        0 2px 18px rgba(0,0,0,.55),
        0 0 30px rgba(255,240,210,.10);
    }

    .sub{
      margin:14px 0 0 0;
      color: rgba(184,215,202,.92);
      font-size: 13px;
      line-height:1.45;
      text-shadow: 0 2px 16px rgba(0,0,0,.55);
    }

    /* Typewriter cursor blink */
    @keyframes blink { 0%,49%{opacity:1} 50%,100%{opacity:0} }

    /* Slight mobile tuning */
    @media (max-width: 520px){
      input[type="range"]{width:90px}
      .hud{gap:8px}
      .capyWrap{width:min(940px, 96vw)}
      .overlay{padding: 18px 14px}
    }

    /* iOS perf: blend modes are expensive; disable them */
    .ios .capy{ mix-blend-mode: normal; }
  </style>
</head>

<body>
  <canvas id="sky"></canvas>
  <canvas id="snow"></canvas>

  <div class="hud">
    <div class="title" id="hudTitle">üéÑ Merry Christmas</div>
    <button class="btn" id="musicBtn">‚ñ∂ Play music</button>
    <button class="btn secondary" id="snowBtn">Snow: ON ‚ùÑ</button>
    <div class="slider">
      Volume
      <input id="vol" type="range" min="0" max="100" value="55" />
    </div>
  </div>

  <div class="scene">
    <div class="capyWrap">
      <div class="halo"></div>

      <!-- Put Capu.jpg in the same folder as this HTML (or adjust the path) -->
      <img class="capy" src="./Capu.jpg" alt="Festive Capu" />

      <div class="overlay">
        <h1 class="headline" id="headline"></h1>
        <p class="message" id="msg"></p>
        <p class="sub">Music won‚Äôt autoplay; click Play once.</p>
      </div>
    </div>
  </div>

  <!-- If your MP3 filename has spaces, keep %20 or (better) rename it. -->
  <audio id="bgm" preload="auto" loop>
    <source src="./Ho%20Ho%20Ho%20Jingle%20Bell.mp3" type="audio/mpeg">
  </audio>

<script>
/* =========================
   Device profile (best for iPhone 15 Pro / iOS WebKit)
   ========================= */
(function(){
  const ua = navigator.userAgent || "";
  const isIOS = /iPhone|iPad|iPod/i.test(ua) ||
                (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  if (isIOS) document.documentElement.classList.add("ios");

  const prefersReducedMotion = window.matchMedia &&
    window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  /* =========================
     Typewriter text (FULL + safe)
     ========================= */
  const HEADLINE_TEXT = "‚ú® Merry Xmas ‚ú®";
  const MESSAGE_TEXT = `Dear ch·ªã C√∫n,

üéÑ Merry Christmas! üéÑ

Ch√∫c ch·ªã C√∫n m√πa Gi√°ng Sinh an l√†nh v√† NƒÉm M·ªõi nhi·ªÅu ni·ªÅm vui, s·ª©c kh·ªèe, th√†nh c√¥ng, l√™n band c√πng anh Miu v√† lu√¥n y√™u th∆∞∆°ng, kh√¥ng m·∫Øng em (nhi·ªÅu) n·ªØa.

‚Äî From Capu b√© b·ªèng m≈©i cao with love ü§ü
(ch·ªã C√∫n nh·ªõ click v√†o "Play music" nh√° ü§úü§õ)`;

  const headlineEl = document.getElementById("headline");
  const msgEl = document.getElementById("msg");

  function typeWriter(el, text, opts = {}){
    const {
      cps = 22,          // chars per second
      startDelay = 0,    // ms
      jitter = 0.25,     // randomness
      cursor = true
    } = opts;

    el.textContent = "";
    let i = 0;

    let cursorEl = null;
    if (cursor){
      cursorEl = document.createElement("span");
      cursorEl.textContent = "‚ñç";
      cursorEl.style.opacity = "0.85";
      cursorEl.style.marginLeft = "2px";
      cursorEl.style.animation = "blink 1s steps(2,end) infinite";
      el.appendChild(cursorEl);
    }

    const base = 1000 / Math.max(1, cps);

    function tick(){
      if (i >= text.length){
        if (cursorEl) cursorEl.remove();
        return;
      }
      const ch = text[i++];

      if (cursorEl){
        cursorEl.insertAdjacentText("beforebegin", ch);
      } else {
        el.textContent += ch;
      }

      const r = (Math.random()*2 - 1) * jitter; // [-jitter, +jitter]
      const next = Math.max(12, base * (1 + r));
      setTimeout(tick, next);
    }

    setTimeout(tick, startDelay);
  }

  // Start typing (headline then message)
  typeWriter(headlineEl, HEADLINE_TEXT, { cps: isIOS ? 16 : 18, startDelay: 250, jitter: 0.20, cursor: true });
  typeWriter(msgEl, MESSAGE_TEXT,       { cps: isIOS ? 22 : 26, startDelay: 1100, jitter: 0.28, cursor: true });

  /* =========================
     Audio controls (iOS-friendly)
     ========================= */
  document.getElementById("hudTitle").textContent = "üéÑ Merry Christmas";

  const audioEl = document.getElementById("bgm");
  const musicBtn = document.getElementById("musicBtn");
  const vol = document.getElementById("vol");

  function setVol(){ audioEl.volume = Number(vol.value) / 100; }
  vol.addEventListener("input", setVol);
  setVol();

  musicBtn.addEventListener("click", async () => {
    if (audioEl.paused) {
      try{
        audioEl.load();
        await audioEl.play();
        musicBtn.textContent = "‚è∏ Pause music";
      }catch{
        musicBtn.textContent = "‚ñ∂ Play music";
      }
    } else {
      audioEl.pause();
      musicBtn.textContent = "‚ñ∂ Play music";
    }
  });

  /* =========================
     Cinematic sky + single-layer snow (optimized for iOS WebKit)
     Key optimizations:
       - single snow canvas (huge win)
       - hard DPR caps per layer
       - static background pre-render
       - adaptive FPS (sky 30fps, snow 45fps on iOS)
       - pause when tab hidden
       - pre-render snowflake shapes to sprites (no stroking every frame)
     ========================= */
  const skyC = document.getElementById("sky");
  const snowC = document.getElementById("snow");

  const sky = skyC.getContext("2d", { alpha:true, desynchronized:true });
  const snow = snowC.getContext("2d", { alpha:true, desynchronized:true });

  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // Profile tuned for iPhone 15 Pro (still battery-conscious)
  const PROFILE = isIOS ? {
    dprSky: 1.25,      // lower than device DPR (saves fill-rate)
    dprSnow: 1.00,
    skyFPS: 30,
    snowFPS: 45,
    starCap: 420,
    snowCap: 420,
    bokehCap: 18,
    haze: 0.16,
    vignette: 0.26,
    windBase: 12,
    windGust: 26,
    shootMinGap: 7.5,
    shootMaxGap: 14.5
  } : {
    dprSky: Math.min(2, window.devicePixelRatio || 1),
    dprSnow: Math.min(2, window.devicePixelRatio || 1),
    skyFPS: 60,
    snowFPS: 60,
    starCap: 720,
    snowCap: 760,
    bokehCap: 28,
    haze: 0.18,
    vignette: 0.28,
    windBase: 14,
    windGust: 34,
    shootMinGap: 6.5,
    shootMaxGap: 14.0
  };

  const S = {
    w:0,h:0,
    skyDpr:1, snowDpr:1,
    t:0,
    last:0,
    running:true,
    snowOn: !prefersReducedMotion,

    // sky
    stars:[],
    shooters:[],
    nextShoot: 0,

    // snow
    flakes:[],

    // sprites
    sprGlow:[],
    sprBokeh:[],
    sprFlake:[],

    // cached gradients + static bg
    staticSky: null,
    fogGrad: null,

    // frame pacing
    skyAcc: 0,
    snowAcc: 0
  };

  function gust(t){
    return (
      Math.sin(t*0.19)*0.55 +
      Math.sin(t*0.07 + 1.6)*0.35 +
      Math.sin(t*0.011 + 3.9)*0.20
    );
  }

  function makeSpriteCanvas(size){
    const c = document.createElement("canvas");
    c.width = c.height = size;
    return c;
  }

  function buildGlowSprite(size, innerA, midA, outerA){
    const c = makeSpriteCanvas(size);
    const g = c.getContext("2d");
    const cx = size/2, cy = size/2;
    const r0 = size * 0.08;
    const r1 = size * 0.50;

    const grad = g.createRadialGradient(cx, cy, r0, cx, cy, r1);
    grad.addColorStop(0.00, `rgba(255,255,255,${innerA})`);
    grad.addColorStop(0.28, `rgba(255,255,255,${midA})`);
    grad.addColorStop(0.70, `rgba(255,255,255,${outerA})`);
    grad.addColorStop(1.00, "rgba(255,255,255,0)");

    g.fillStyle = grad;
    g.beginPath(); g.arc(cx, cy, r1, 0, Math.PI*2); g.fill();

    // tiny bright core
    g.fillStyle = "rgba(255,255,255,0.90)";
    g.beginPath(); g.arc(cx, cy, Math.max(1, size*0.04), 0, Math.PI*2); g.fill();
    return c;
  }

  function buildSnowflakeSprite(size, arms = 6, thick = 1.4){
    const c = makeSpriteCanvas(size);
    const g = c.getContext("2d");
    const cx = size/2, cy = size/2;

    const baseR = size * 0.36;
    const branchR = baseR * 0.34;

    g.translate(cx, cy);

    // glow pass
    g.globalAlpha = 0.35;
    g.strokeStyle = "rgba(255,255,255,1)";
    g.lineCap = "round";
    g.lineJoin = "round";
    g.lineWidth = thick * 2.6;
    for(let i=0;i<arms;i++){
      const ang = (Math.PI*2*i)/arms;
      g.beginPath();
      g.moveTo(0,0);
      g.lineTo(Math.cos(ang)*baseR, Math.sin(ang)*baseR);
      g.stroke();
    }

    // sharp pass
    g.globalAlpha = 1;
    g.lineWidth = thick * 1.2;
    for(let i=0;i<arms;i++){
      const ang = (Math.PI*2*i)/arms;
      const x2 = Math.cos(ang)*baseR, y2 = Math.sin(ang)*baseR;

      g.beginPath();
      g.moveTo(0,0);
      g.lineTo(x2,y2);
      g.stroke();

      const bx = Math.cos(ang) * baseR * 0.64;
      const by = Math.sin(ang) * baseR * 0.64;

      const bAng1 = ang + Math.PI/6;
      const bAng2 = ang - Math.PI/6;

      g.beginPath();
      g.moveTo(bx,by);
      g.lineTo(bx + Math.cos(bAng1)*branchR, by + Math.sin(bAng1)*branchR);
      g.stroke();

      g.beginPath();
      g.moveTo(bx,by);
      g.lineTo(bx + Math.cos(bAng2)*branchR, by + Math.sin(bAng2)*branchR);
      g.stroke();
    }

    // core dot
    g.fillStyle = "rgba(255,255,255,0.92)";
    g.beginPath();
    g.arc(0,0, Math.max(1, baseR*0.12), 0, Math.PI*2);
    g.fill();

    return c;
  }

  function buildSprites(){
    // Glow flakes
    S.sprGlow = [
      buildGlowSprite(18, 0.95, 0.55, 0.16),
      buildGlowSprite(26, 0.95, 0.55, 0.14),
      buildGlowSprite(36, 0.95, 0.50, 0.12),
      buildGlowSprite(52, 0.95, 0.46, 0.10)
    ];

    // Lens bokeh
    S.sprBokeh = [
      buildGlowSprite(110, 0.30, 0.12, 0.03),
      buildGlowSprite(160, 0.24, 0.10, 0.025),
      buildGlowSprite(220, 0.20, 0.08, 0.02)
    ];

    // Crisp snowflake shapes (pre-rendered!)
    S.sprFlake = [
      buildSnowflakeSprite(34, 6, 1.2),
      buildSnowflakeSprite(42, 6, 1.3),
      buildSnowflakeSprite(52, 6, 1.4),
      buildSnowflakeSprite(64, 6, 1.5),
      buildSnowflakeSprite(74, 6, 1.6)
    ];
  }

  function seedStars(){
    const count = PROFILE.starCap;
    S.stars = Array.from({length: count}, () => ({
      x: Math.random()*S.w,
      y: Math.random()*S.h*0.82,
      r: 0.35 + Math.random()*1.10,
      a: 0.22 + Math.random()*0.62,
      tw: 0.6 + Math.random()*2.2,
      ph: Math.random()*Math.PI*2
    }));
  }

  function makeShooter(){
    const fromLeft = Math.random() < 0.65;
    const startX = fromLeft ? -S.w*0.1 : S.w*1.1;
    const startY = Math.random() * S.h * 0.35 + 10;

    const ang = fromLeft ? (Math.PI * (0.10 + Math.random()*0.10))
                         : (Math.PI * (0.90 - Math.random()*0.10));

    const speed = 900 + Math.random()*650;
    const len = 240 + Math.random()*220;
    const life = 0.55 + Math.random()*0.40;

    return {
      x:startX, y:startY,
      vx: Math.cos(ang)*speed,
      vy: Math.sin(ang)*speed,
      len,
      life,
      age:0,
      glow: 0.7 + Math.random()*0.7
    };
  }

  function scheduleNextShoot(){
    const gap = lerp(PROFILE.shootMinGap, PROFILE.shootMaxGap, Math.random());
    S.nextShoot = S.t + gap;
  }

  function seedSnow(){
    const n = PROFILE.snowCap;
    const bN = PROFILE.bokehCap;

    S.flakes = [];

    // Bokeh (few but large)
    for(let i=0;i<bN;i++){
      S.flakes.push({
        kind: "bokeh",
        x: Math.random()*S.w,
        y: Math.random()*S.h,
        vx: (Math.random()*2 - 1) * 8,
        vy: 20 + Math.random()*34,
        idx: Math.floor(Math.random()*S.sprBokeh.length),
        a: 0.10 + Math.random()*0.16,
        s: 0.45 + Math.random()*0.85,
        ph: Math.random()*Math.PI*2
      });
    }

    // Snow particles (glow + crisp)
    for(let i=bN;i<n;i++){
      const z = Math.random();
      const isCrisp = Math.random() < (isIOS ? 0.32 : 0.40);

      const size = lerp(0.75, 1.35, Math.pow(z, 1.25));
      const fall = lerp(70, 220, Math.pow(z, 1.05));
      const alpha = lerp(0.14, 0.62, Math.pow(z, 1.0));

      S.flakes.push({
        kind: isCrisp ? "flake" : "glow",
        x: Math.random()*S.w,
        y: Math.random()*S.h,
        z,
        size,
        fall,
        alpha,
        ph: Math.random()*Math.PI*2,
        wob: 0.4 + Math.random()*1.1,
        spin: (Math.random()*2 - 1) * 0.8,
        sparkle: (Math.random() < 0.12) ? lerp(1.05, 1.40, Math.random()) : 1.0,
        idx: isCrisp
          ? Math.floor(Math.random()*S.sprFlake.length)
          : (z < 0.35 ? 0 : z < 0.65 ? 1 : z < 0.85 ? 2 : 3)
      });
    }
  }

  function buildStaticSky(){
    const c = document.createElement("canvas");
    c.width = skyC.width;
    c.height = skyC.height;
    const g = c.getContext("2d");

    // Work in device pixels
    g.setTransform(1,0,0,1,0,0);
    g.clearRect(0,0,c.width,c.height);

    // Convert to CSS pixels drawing by applying inverse scale
    g.setTransform(S.skyDpr,0,0,S.skyDpr,0,0);

    // Base dark wash
    const bg = g.createLinearGradient(0,0,0,S.h);
    bg.addColorStop(0, "rgba(2,10,8,0.00)");
    bg.addColorStop(0.35, "rgba(2,10,8,0.10)");
    bg.addColorStop(1, "rgba(0,0,0,0.28)");
    g.fillStyle = bg;
    g.fillRect(0,0,S.w,S.h);

    // Moon glow
    const mx = S.w * 0.20;
    const my = S.h * 0.18;
    const mr = Math.min(S.w,S.h) * 0.22;
    const mg = g.createRadialGradient(mx,my, mr*0.06, mx,my, mr);
    mg.addColorStop(0.00, "rgba(255,240,210,0.18)");
    mg.addColorStop(0.25, "rgba(255,240,210,0.08)");
    mg.addColorStop(1.00, "rgba(255,240,210,0.00)");
    g.fillStyle = mg;
    g.fillRect(0,0,S.w,S.h);

    // Haze
    const hz = g.createRadialGradient(S.w*0.55, S.h*0.38, S.h*0.10, S.w*0.55, S.h*0.38, S.h*0.75);
    hz.addColorStop(0.00, `rgba(255,255,255,${PROFILE.haze*0.22})`);
    hz.addColorStop(0.45, `rgba(255,255,255,${PROFILE.haze*0.10})`);
    hz.addColorStop(1.00, "rgba(255,255,255,0)");
    g.fillStyle = hz;
    g.fillRect(0,0,S.w,S.h);

    // Vignette
    const vg = g.createRadialGradient(S.w*0.5, S.h*0.45, S.h*0.20, S.w*0.5, S.h*0.45, S.h*0.95);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, `rgba(0,0,0,${PROFILE.vignette})`);
    g.fillStyle = vg;
    g.fillRect(0,0,S.w,S.h);

    S.staticSky = c;
  }

  function buildFog(){
    // Fog gradient used in snow draw (CSS pixels)
    S.fogGrad = snow.createLinearGradient(0, S.h*0.58, 0, S.h);
    S.fogGrad.addColorStop(0.0, "rgba(255,255,255,0)");
    S.fogGrad.addColorStop(1.0, "rgba(255,255,255,0.055)");
  }

  function resize(){
    S.w = window.innerWidth;
    S.h = window.innerHeight;

    // Hard DPR caps per layer
    const dprBase = window.devicePixelRatio || 1;
    S.skyDpr = clamp(PROFILE.dprSky, 1, Math.min(2, dprBase));
    S.snowDpr = clamp(PROFILE.dprSnow, 1, Math.min(2, dprBase));

    // Size canvases in device pixels
    skyC.width = Math.floor(S.w * S.skyDpr);
    skyC.height = Math.floor(S.h * S.skyDpr);
    skyC.style.width = S.w + "px";
    skyC.style.height = S.h + "px";

    snowC.width = Math.floor(S.w * S.snowDpr);
    snowC.height = Math.floor(S.h * S.snowDpr);
    snowC.style.width = S.w + "px";
    snowC.style.height = S.h + "px";

    buildSprites();
    seedStars();
    seedSnow();
    buildStaticSky();

    // rebuild fog gradient in snow context space
    snow.setTransform(S.snowDpr,0,0,S.snowDpr,0,0);
    buildFog();

    scheduleNextShoot();
  }

  function stepShooters(dt){
    if (S.t >= S.nextShoot && Math.random() < 0.9){
      S.shooters.push(makeShooter());
      scheduleNextShoot();
    }
    for(let i=S.shooters.length-1;i>=0;i--){
      const sh = S.shooters[i];
      sh.age += dt;
      sh.x += sh.vx * dt;
      sh.y += sh.vy * dt;
      if (sh.age > sh.life || sh.y > S.h*1.2) S.shooters.splice(i,1);
    }
  }

  function stepSnow(dt){
    const g = gust(S.t);
    const wind = PROFILE.windBase + PROFILE.windGust * g;

    for(const f of S.flakes){
      if (f.kind === "bokeh"){
        f.ph += dt * 0.6;
        f.x += (f.vx + Math.sin(f.ph)*6) * dt;
        f.y += f.vy * dt;

        if(f.y > S.h + 240){ f.y = -240; f.x = Math.random()*S.w; }
        if(f.x < -260) f.x = S.w + 260;
        if(f.x > S.w + 260) f.x = -260;
        continue;
      }

      const depth = lerp(0.35, 1.25, f.z);
      const swirl = Math.sin(f.ph + S.t*(0.9 + f.wob)) * 18 * lerp(0.2, 1.0, f.z);

      f.y += f.fall * dt;
      f.x += (wind * depth + swirl) * dt;
      f.ph += dt * (0.55 + f.wob) * 0.9;

      if(f.y > S.h + 60){ f.y = -60; f.x = Math.random()*S.w; }
      if(f.x < -80) f.x = S.w + 80;
      if(f.x > S.w + 80) f.x = -80;
    }
  }

  function drawSky(){
    // Draw static cached layer first
    sky.setTransform(1,0,0,1,0,0);
    sky.clearRect(0,0,skyC.width,skyC.height);
    if (S.staticSky) sky.drawImage(S.staticSky, 0, 0);

    // Now draw dynamic things in CSS pixels space
    sky.setTransform(S.skyDpr,0,0,S.skyDpr,0,0);

    // Stars (kept light)
    for(const st of S.stars){
      const tw = 0.5 + 0.5*Math.sin(S.t*st.tw + st.ph);
      const a = clamp(st.a * (0.7 + 0.6*tw), 0, 1);
      sky.fillStyle = `rgba(255,255,255,${a})`;
      sky.beginPath();
      sky.arc(st.x, st.y, st.r * (0.85 + 0.25*tw), 0, Math.PI*2);
      sky.fill();
    }

    // Shooting stars (only place we do additive; limited count)
    if(S.shooters.length){
      sky.globalCompositeOperation = "lighter";
      for(const sh of S.shooters){
        const p = clamp(sh.age / sh.life, 0, 1);
        const fade = (p < 0.2) ? (p/0.2) : (p > 0.85) ? (1 - (p-0.85)/0.15) : 1;
        const a = 0.85 * fade * sh.glow;

        const mag = Math.max(1, Math.hypot(sh.vx, sh.vy));
        const dx = sh.vx / mag, dy = sh.vy / mag;

        const x2 = sh.x - dx * sh.len;
        const y2 = sh.y - dy * sh.len;

        const grad = sky.createLinearGradient(sh.x, sh.y, x2, y2);
        grad.addColorStop(0.00, `rgba(255,255,255,${a})`);
        grad.addColorStop(0.25, `rgba(255,240,200,${a*0.55})`);
        grad.addColorStop(0.70, `rgba(180,220,255,${a*0.18})`);
        grad.addColorStop(1.00, "rgba(180,220,255,0)");

        sky.strokeStyle = grad;
        sky.lineWidth = 2.0 + 1.6*(1-p);
        sky.lineCap = "round";
        sky.beginPath();
        sky.moveTo(sh.x, sh.y);
        sky.lineTo(x2, y2);
        sky.stroke();

        const rg = sky.createRadialGradient(sh.x, sh.y, 0, sh.x, sh.y, 24);
        rg.addColorStop(0, `rgba(255,255,255,${a*0.55})`);
        rg.addColorStop(1, "rgba(255,255,255,0)");
        sky.fillStyle = rg;
        sky.beginPath();
        sky.arc(sh.x, sh.y, 24, 0, Math.PI*2);
        sky.fill();
      }
      sky.globalCompositeOperation = "source-over";
    }
  }

  function drawSnow(){
    snow.setTransform(1,0,0,1,0,0);
    snow.clearRect(0,0,snowC.width,snowC.height);
    if (!S.snowOn) return;

    snow.setTransform(S.snowDpr,0,0,S.snowDpr,0,0);

    const driftX = Math.sin(S.t*0.12) * 1.6;
    const driftY = Math.cos(S.t*0.10) * 1.2;

    for(const f of S.flakes){
      if (f.kind === "bokeh"){
        const spr = S.sprBokeh[f.idx];
        const w = spr.width * f.s;
        const h = spr.height * f.s;
        const tw = 0.7 + 0.3*Math.sin(S.t*0.8 + f.ph);
        snow.globalAlpha = clamp(f.a * tw, 0, 1);
        snow.drawImage(spr, f.x - w/2 + driftX, f.y - h/2 + driftY, w, h);
        continue;
      }

      const tw = 0.9 + 0.1*Math.sin(S.t*1.6 + f.ph);
      const a = clamp(f.alpha * tw * f.sparkle, 0, 1);
      snow.globalAlpha = a;

      if (f.kind === "flake"){
        const spr = S.sprFlake[f.idx];
        const s = f.size * 0.75;
        const w = spr.width * s;
        const h = spr.height * s;

        // rotate only some flakes (cheaper overall)
        if (f.z > 0.72){
          snow.save();
          snow.translate(f.x + driftX, f.y + driftY);
          snow.rotate(f.spin * 0.10);
          snow.drawImage(spr, -w/2, -h/2, w, h);
          snow.restore();
        } else {
          snow.drawImage(spr, f.x - w/2 + driftX, f.y - h/2 + driftY, w, h);
        }
      } else {
        const spr = S.sprGlow[f.idx];
        const s = f.size * 0.64;
        const w = spr.width * s;
        const h = spr.height * s;
        snow.drawImage(spr, f.x - w/2 + driftX, f.y - h/2 + driftY, w, h);
      }
    }

    // subtle fog band (cached)
    snow.globalAlpha = 1;
    snow.fillStyle = S.fogGrad;
    snow.fillRect(0,0,S.w,S.h);
  }

  function tick(ts){
    if (!S.running){
      requestAnimationFrame(tick);
      return;
    }
    if(!S.last) S.last = ts;
    const dt = Math.min(0.033, (ts - S.last)/1000);
    S.last = ts;

    S.t += dt;

    // Update physics every frame (cheap enough), render at capped FPS
    if (S.snowOn) stepSnow(dt);
    stepShooters(dt);

    // Accumulate time for paced draws
    S.skyAcc += dt;
    S.snowAcc += dt;

    const skyStep = 1 / PROFILE.skyFPS;
    const snowStep = 1 / PROFILE.snowFPS;

    if (S.skyAcc >= skyStep){
      // keep acc bounded to avoid spiral
      S.skyAcc = S.skyAcc % skyStep;
      drawSky();
    }
    if (S.snowAcc >= snowStep){
      S.snowAcc = S.snowAcc % snowStep;
      drawSnow();
    }

    requestAnimationFrame(tick);
  }

  // Snow toggle
  const snowBtn = document.getElementById("snowBtn");
  snowBtn.addEventListener("click", ()=>{
    S.snowOn = !S.snowOn;
    snowBtn.textContent = S.snowOn ? "Snow: ON ‚ùÑ" : "Snow: OFF";
    if (!S.snowOn){
      // clear snow immediately
      snow.setTransform(1,0,0,1,0,0);
      snow.clearRect(0,0,snowC.width,snowC.height);
    }
  });

  // Pause when hidden (major battery win on iPhone)
  document.addEventListener("visibilitychange", ()=>{
    S.running = !document.hidden;
    if (document.hidden){
      S.last = 0;
    }
  });

  // Resize handling (debounced)
  let rTO = null;
  window.addEventListener("resize", ()=>{
    clearTimeout(rTO);
    rTO = setTimeout(resize, 120);
  });

  // Start
  resize();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
