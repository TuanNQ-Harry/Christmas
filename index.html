<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üéÑ Merry Christmas</title>
  <style>
    :root{
      --bg1:#03110c;
      --bg2:#082319;

      --text:#eaf7f0;
      --muted:#b8d7ca;
      --gold:#ffd36a;

      --uiGlass: rgba(0,0,0,.18);
      --uiBorder: rgba(255,255,255,.12);
      --textAlpha: .94;
      --imgAlpha: .98;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial}
    body{
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(255,255,255,.06), transparent 55%),
        radial-gradient(900px 700px at 80% 20%, rgba(255,211,106,.10), transparent 55%),
        linear-gradient(140deg,var(--bg1),var(--bg2));
      overflow:hidden;
    }

    /* Canvases */
    canvas{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      pointer-events:none;
    }
    #sky{ z-index:0; }
    #snowBack{ z-index:1; }
    #snowFront{ z-index:6; }

    /* Minimal HUD */
    .hud{
      position:fixed;
      left:50%;
      top:16px;
      transform:translateX(-50%);
      z-index:7;

      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;

      padding:10px 12px;
      border-radius:999px;

      background: var(--uiGlass);
      border: 1px solid var(--uiBorder);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .title{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(234,247,240,.90);
      font-size:13px;
      user-select:none;
      white-space:nowrap;
    }
    .btn{
      cursor:pointer;
      padding:8px 12px;
      border-radius:999px;
      background:rgba(255,211,106,.12);
      border:1px solid rgba(255,211,106,.30);
      color:rgba(234,247,240,.95);
      font-weight:650;
      font-size:13px;
      user-select:none;
    }
    .btn.secondary{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
    }
    .btn:hover{filter:brightness(1.08)}
    .btn:active{transform:translateY(1px)}
    .slider{
      display:flex; align-items:center; gap:8px;
      padding:7px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      font-size:13px;
      color:rgba(184,215,202,.95);
      user-select:none;
    }
    input[type="range"]{width:110px}

    /* Scene (single hero) */
    .scene{
      position:relative;
      z-index:3;
      height:100%;
      display:grid;
      place-items:center;
      padding:88px 18px 18px; /* space for HUD */
    }

    /* Capy wrapper */
    .capyWrap{
      position:relative;
      width:min(720px, 92vw);
      margin-inline:auto;
      isolation:isolate; /* keeps blending sane */
    }

    .halo{
      position:absolute;
      inset:-10% -10% -10% -10%;
      z-index:0;
      background:
        radial-gradient(closest-side at 50% 35%, rgba(255,211,106,.14), transparent 62%),
        radial-gradient(closest-side at 35% 55%, rgba(255,255,255,.06), transparent 62%),
        radial-gradient(closest-side at 65% 65%, rgba(180,220,255,.05), transparent 62%);
      filter: blur(18px);
      opacity:.95;
      pointer-events:none;
    }

    .capy{
      position:relative;
      z-index:1;
      width:100%;
      height:auto;
      display:block;
      opacity: var(--imgAlpha);
      border-radius:22px;

      filter:
        drop-shadow(0 24px 65px rgba(0,0,0,.42))
        drop-shadow(0 0 34px rgba(255,240,210,.12));

      /* makes it feel embedded into the glow */
      mix-blend-mode: screen;
    }

    /* TEXT OVER THE IMAGE (VERTICAL) */
    .overlay{
      position:absolute;
      inset:0;
      z-index:2;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start; /* stick to top of image */
      text-align:center;

      padding: clamp(18px, 4.2vw, 44px) clamp(14px, 4vw, 40px);
      pointer-events:none;

      opacity: var(--textAlpha);

      /* gentle cinematic ‚Äúlift‚Äù so text reads on busy areas without a card */
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,.28),
        rgba(0,0,0,.10) 40%,
        rgba(0,0,0,0) 72%
      );
      border-radius:22px;
    }

    .headline{
      margin:0 0 10px 0;
      font-size: clamp(30px, 4.2vw, 56px);
      line-height:1.05;
      letter-spacing:-0.6px;

      background: linear-gradient(
        90deg,
        rgba(255,255,255,.96),
        rgba(255,211,106,.92),
        rgba(210,240,255,.92)
      );
      -webkit-background-clip:text;
      background-clip:text;
      color: transparent;

      text-shadow:
        0 3px 26px rgba(0,0,0,.55),
        0 0 36px rgba(255,240,210,.12);
    }

    .message{
      margin:0;
      max-width: 52ch;
      font-size: clamp(15px, 1.6vw, 18px);
      line-height:1.55;
      color: rgba(234,247,240,.94);
      white-space:pre-wrap;

      text-shadow:
        0 2px 18px rgba(0,0,0,.55),
        0 0 30px rgba(255,240,210,.10);

      /* optional ‚Äúblend into glow‚Äù; if too washed out, change to normal */
      mix-blend-mode: screen;
    }

    .sub{
      margin:14px 0 0 0;
      color: rgba(184,215,202,.92);
      font-size: 13px;
      line-height:1.45;
      text-shadow: 0 2px 16px rgba(0,0,0,.55);
    }

    .floorFade{
      position:fixed;
      left:0; right:0; bottom:0;
      height:32vh;
      z-index:2;
      pointer-events:none;
      background: linear-gradient(to top, rgba(0,0,0,.34), rgba(0,0,0,0));
    }

    /* Typewriter cursor blink */
    @keyframes blink { 50% { opacity: 0; } }
  </style>
</head>

<body>
  <canvas id="sky"></canvas>
  <canvas id="snowBack"></canvas>
  <div class="floorFade"></div>

  <div class="hud">
    <div class="title" id="hudTitle">üéÑ Merry Christmas</div>
    <button class="btn" id="musicBtn">‚ñ∂ Play music</button>
    <button class="btn secondary" id="snowBtn">Snow: ON ‚ùÑ</button>
    <div class="slider">
      Volume
      <input id="vol" type="range" min="0" max="100" value="55" />
    </div>
  </div>

  <div class="scene">
    <div class="capyWrap">
      <div class="halo"></div>

      <!-- Put your image in the repo (same folder as this HTML) -->
      <img class="capy" src="./Capu.jpg" alt="Festive Capu" />

      <!-- Text on top of the image (vertical stack) -->
      <div class="overlay">
        <!-- These will be overwritten by the typewriter script -->
        <h1 class="headline" id="headline"></h1>
        <p class="message" id="msg"></p>        
      </div>
    </div>
  </div>

  <canvas id="snowFront"></canvas>

  <!-- Put your audio in the repo (same folder as this HTML).
       Avoid spaces in filename for GitHub Pages reliability. -->
  <audio id="bgm" preload="auto" loop>
    <source src="./jingle-bells.mp3" type="audio/mpeg">
  </audio>

  <script>
/* =========================
   Simple UI text (optional)
   ========================= */
document.getElementById("hudTitle").textContent = "üéÑ Merry Christmas";

/* =========================
   Typewriter overlay text
   ========================= */
const headlineEl = document.getElementById("headline");
const msgEl = document.getElementById("msg");

// Put your final text here
const HEADLINE_TEXT = "‚ú® Merry Xmas ‚ú®";
const MESSAGE_TEXT = `Dear ch·ªã C√∫n,

üéÑ Merry Christmas! üéÑ

Ch√∫c ch·ªã C√∫n m√πa Gi√°ng Sinh an l√†nh v√† NƒÉm M·ªõi nhi·ªÅu ni·ªÅm vui, s·ª©c kh·ªèe, th√†nh c√¥ng, l√™n band c√πng anh Miu v√† lu√¥n y√™u th∆∞∆°ng, kh√¥ng m·∫Øng em (nhi·ªÅu) n·ªØa.

‚Äî From Capu b√© b·ªèng m≈©i cao with love ü§ü
(ch·ªã C√∫n nh·ªõ click v√†o "Play music" nh√° ü§úü§õ)`;

function typeWriter(el, text, {
  cps = 22,          // characters per second
  startDelay = 0,    // ms
  jitter = 0.35,     // randomness in speed
  cursor = true
} = {}){
  el.textContent = "";
  let i = 0;

  let cursorEl = null;
  if(cursor){
    cursorEl = document.createElement("span");
    cursorEl.textContent = "‚ñç";
    cursorEl.style.opacity = "0.85";
    cursorEl.style.marginLeft = "2px";
    cursorEl.style.animation = "blink 1s steps(2,end) infinite";
    el.appendChild(cursorEl);
  }

  const base = 1000 / Math.max(1, cps);

  function tick(){
    if(i >= text.length){
      if(cursorEl) cursorEl.remove();
      return;
    }

    const ch = text[i++];
    if(cursorEl){
      cursorEl.insertAdjacentText("beforebegin", ch);
    }else{
      el.textContent += ch;
    }

    const r = (Math.random()*2 - 1) * jitter; // [-jitter, +jitter]
    const next = base * (1 + r);
    setTimeout(tick, Math.max(10, next));
  }

  setTimeout(tick, startDelay);
}

// Run sequence: headline then message
typeWriter(headlineEl, HEADLINE_TEXT, { cps: 18, startDelay: 250, jitter: 0.25, cursor: true });
typeWriter(msgEl, MESSAGE_TEXT, { cps: 28, startDelay: 1200, jitter: 0.35, cursor: true });

/* =========================
   Cinematic sky + snow + shooting stars
   ========================= */
(function(){
  const skyC = document.getElementById("sky");
  const backC = document.getElementById("snowBack");
  const frontC = document.getElementById("snowFront");

  const sky = skyC.getContext("2d", { alpha:true });
  const back = backC.getContext("2d", { alpha:true });
  const front = frontC.getContext("2d", { alpha:true });

  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const lerp = (a,b,t)=>a+(b-a)*t;

  const S = {
    w:0,h:0,dpr:1,
    t:0,last:0,
    snowOn:true,
    stars:[],
    shooters:[],
    flakesBack:[],
    flakesFront:[],
    sprites:{ snow:[], bokeh:[] },
    nextShoot:0
  };

  const CFG = {
    starCountPerPixel: 0.000015,
    starCap: 720,

    shootMinGap: 6.5,
    shootMaxGap: 14.0,
    shootChance: 1.0,

    backDensity: 0.000045,
    frontDensity: 0.000020,
    snowCapBack: 680,
    snowCapFront: 230,

    windBase: 14,
    windGust: 34,

    vignette: 0.28,
    haze: 0.18
  };

  function gust(t){
    return (
      Math.sin(t*0.19)*0.55 +
      Math.sin(t*0.07 + 1.6)*0.35 +
      Math.sin(t*0.011 + 3.9)*0.20
    );
  }

  function resize(){
    S.dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    S.w = window.innerWidth;
    S.h = window.innerHeight;

    for(const c of [skyC, backC, frontC]){
      c.width = Math.floor(S.w * S.dpr);
      c.height = Math.floor(S.h * S.dpr);
      c.style.width = S.w + "px";
      c.style.height = S.h + "px";
    }
    buildSprites();
    seedStars();
    seedSnow(true);
  }

  function buildSprites(){
    const makeRadial = (size, stops) => {
      const c = document.createElement("canvas");
      c.width = c.height = size;
      const g = c.getContext("2d");
      const cx = size/2, cy = size/2;
      const grad = g.createRadialGradient(cx, cy, size*0.08, cx, cy, size*0.5);
      for(const [p, col] of stops) grad.addColorStop(p, col);
      g.fillStyle = grad;
      g.beginPath(); g.arc(cx, cy, size*0.5, 0, Math.PI*2); g.fill();
      g.fillStyle = "rgba(255,255,255,0.88)";
      g.beginPath(); g.arc(cx, cy, size*0.06, 0, Math.PI*2); g.fill();
      return c;
    };

    S.sprites.snow = [
      makeRadial(18, [[0,"rgba(255,255,255,.95)"],[.25,"rgba(255,255,255,.55)"],[.65,"rgba(255,255,255,.16)"],[1,"rgba(255,255,255,0)"]]),
      makeRadial(26, [[0,"rgba(255,255,255,.95)"],[.25,"rgba(255,255,255,.55)"],[.65,"rgba(255,255,255,.14)"],[1,"rgba(255,255,255,0)"]]),
      makeRadial(36, [[0,"rgba(255,255,255,.95)"],[.25,"rgba(255,255,255,.50)"],[.65,"rgba(255,255,255,.12)"],[1,"rgba(255,255,255,0)"]]),
      makeRadial(52, [[0,"rgba(255,255,255,.95)"],[.22,"rgba(255,255,255,.46)"],[.62,"rgba(255,255,255,.10)"],[1,"rgba(255,255,255,0)"]])
    ];

    S.sprites.bokeh = [
      makeRadial(120, [[0,"rgba(255,255,255,.34)"],[.25,"rgba(255,255,255,.12)"],[.7,"rgba(255,255,255,.03)"],[1,"rgba(255,255,255,0)"]]),
      makeRadial(180, [[0,"rgba(255,255,255,.26)"],[.22,"rgba(255,255,255,.10)"],[.7,"rgba(255,255,255,.025)"],[1,"rgba(255,255,255,0)"]]),
      makeRadial(240, [[0,"rgba(255,255,255,.20)"],[.20,"rgba(255,255,255,.08)"],[.7,"rgba(255,255,255,.02)"],[1,"rgba(255,255,255,0)"]])
    ];
  }

  function seedStars(){
    const target = Math.min(CFG.starCap, Math.floor(S.w * S.h * CFG.starCountPerPixel));
    S.stars = Array.from({length: target}, () => ({
      x: Math.random()*S.w,
      y: Math.random()*S.h*0.85,
      r: 0.3 + Math.random()*1.25,
      a: 0.25 + Math.random()*0.65,
      tw: 0.6 + Math.random()*2.2,
      ph: Math.random()*Math.PI*2
    }));
  }

  function makeShooter(){
    const fromLeft = Math.random() < 0.65;
    const startX = fromLeft ? -S.w*0.1 : S.w*1.1;
    const startY = Math.random() * S.h * 0.35 + 10;

    const ang = fromLeft ? (Math.PI * (0.10 + Math.random()*0.10))
                         : (Math.PI * (0.90 - Math.random()*0.10));

    const speed = 900 + Math.random()*650;
    const len = 260 + Math.random()*240;
    const life = 0.55 + Math.random()*0.40;

    return { x:startX, y:startY,
      vx: Math.cos(ang)*speed,
      vy: Math.sin(ang)*speed,
      len, life, age:0,
      glow: 0.7 + Math.random()*0.7
    };
  }

  function scheduleNextShoot(){
    const gap = lerp(CFG.shootMinGap, CFG.shootMaxGap, Math.random());
    S.nextShoot = S.t + gap / Math.max(0.1, CFG.shootChance);
  }

  function seedSnow(reseed){
    const backTarget = Math.min(CFG.snowCapBack, Math.floor(S.w*S.h*CFG.backDensity));
    const frontTarget = Math.min(CFG.snowCapFront, Math.floor(S.w*S.h*CFG.frontDensity));

    const mkFlake = (mode) => {
      const z = Math.random();
      const far = (mode === "back");
      const spriteIdx = (z < 0.35) ? 0 : (z < 0.65) ? 1 : (z < 0.85) ? 2 : 3;

      // balanced: fewer crisp shapes in the far layer
      const type = (Math.random() < (far ? 0.22 : 0.38)) ? "flake" : "glow";
      const arms = (Math.random() < 0.75) ? 6 : (5 + Math.floor(Math.random()*3));
      const thick = 1.1 + Math.random()*1.0;

      const size  = far ? lerp(0.50, 1.10, Math.pow(z, 1.2)) : lerp(0.85, 1.55, Math.pow(z, 1.25));
      const fall  = far ? lerp(22, 120, Math.pow(z, 1.1))  : lerp(60, 220, Math.pow(z, 1.1));
      const alpha = far ? lerp(0.10, 0.52, Math.pow(z, 1.0)) : lerp(0.14, 0.62, Math.pow(z, 1.0));

      return {
        x: Math.random()*S.w,
        y: Math.random()*S.h,
        z, size, fall, alpha,
        spriteIdx,
        ph: Math.random()*Math.PI*2,
        wob: 0.4 + Math.random()*1.2,
        spin: (Math.random()*2 - 1) * 0.9,
        sparkle: (Math.random() < (far ? 0.08 : 0.12)) ? lerp(1.05, 1.55, Math.random()) : 1.0,
        type, arms, thick
      };
    };

    const mkBokeh = () => ({
      x: Math.random()*S.w,
      y: Math.random()*S.h,
      vx: (Math.random()*2 - 1) * 9,
      vy: 18 + Math.random()*35,
      idx: Math.floor(Math.random()*S.sprites.bokeh.length),
      a: 0.10 + Math.random()*0.18,
      s: 0.45 + Math.random()*0.85,
      ph: Math.random()*Math.PI*2
    });

    if(reseed){
      S.flakesBack = [];
      for(let i=0;i<backTarget;i++) S.flakesBack.push(mkFlake("back"));

      S.flakesFront = [];
      const bokehCount = Math.max(8, Math.floor(frontTarget*0.12));
      for(let i=0;i<frontTarget-bokehCount;i++) S.flakesFront.push(mkFlake("front"));
      for(let i=0;i<bokehCount;i++) S.flakesFront.push(mkBokeh());
      return;
    }

    while(S.flakesBack.length < backTarget) S.flakesBack.push(mkFlake("back"));
    while(S.flakesBack.length > backTarget) S.flakesBack.pop();

    while(S.flakesFront.length < frontTarget) S.flakesFront.push(mkFlake("front"));
    while(S.flakesFront.length > frontTarget) S.flakesFront.pop();
  }

  function stepSnow(dt){
    const g = gust(S.t);
    const wind = CFG.windBase + CFG.windGust * g;

    const moveFlake = (f, far) => {
      const depth = far ? lerp(0.18, 0.85, f.z) : lerp(0.35, 1.25, f.z);
      const swirl = Math.sin(f.ph + S.t*(0.9 + f.wob)) * (far ? 12 : 20) * lerp(0.2, 1.0, f.z);

      f.y += f.fall * dt;
      f.x += (wind * depth + swirl) * dt;
      f.ph += dt * (0.55 + f.wob) * 0.9;

      if(f.y > S.h + 60){ f.y = -60; f.x = Math.random()*S.w; }
      if(f.x < -80) f.x = S.w + 80;
      if(f.x > S.w + 80) f.x = -80;
    };

    for(const f of S.flakesBack) moveFlake(f, true);

    for(const f of S.flakesFront){
      if(f.idx !== undefined && f.vx !== undefined){
        f.ph += dt * 0.6;
        f.x += (f.vx + Math.sin(f.ph)*6) * dt;
        f.y += f.vy * dt;

        if(f.y > S.h + 240){ f.y = -240; f.x = Math.random()*S.w; }
        if(f.x < -260) f.x = S.w + 260;
        if(f.x > S.w + 260) f.x = -260;
      }else{
        moveFlake(f, false);
      }
    }
  }

  function stepShooters(dt){
    if(S.t >= S.nextShoot && Math.random() < 0.9){
      S.shooters.push(makeShooter());
      scheduleNextShoot();
    }
    for(let i=S.shooters.length-1;i>=0;i--){
      const sh = S.shooters[i];
      sh.age += dt;
      sh.x += sh.vx * dt;
      sh.y += sh.vy * dt;
      if(sh.age > sh.life || sh.y > S.h*1.2) S.shooters.splice(i,1);
    }
  }

  function drawSky(){
    sky.setTransform(S.dpr,0,0,S.dpr,0,0);
    sky.clearRect(0,0,S.w,S.h);

    const bg = sky.createLinearGradient(0,0,0,S.h);
    bg.addColorStop(0, "rgba(2,10,8,0.00)");
    bg.addColorStop(0.35, "rgba(2,10,8,0.10)");
    bg.addColorStop(1, "rgba(0,0,0,0.28)");
    sky.fillStyle = bg;
    sky.fillRect(0,0,S.w,S.h);

    const mx = S.w * 0.20;
    const my = S.h * 0.18;
    const mr = Math.min(S.w,S.h) * 0.22;
    const mg = sky.createRadialGradient(mx,my, mr*0.06, mx,my, mr);
    mg.addColorStop(0.00, "rgba(255,240,210,0.18)");
    mg.addColorStop(0.25, "rgba(255,240,210,0.08)");
    mg.addColorStop(1.00, "rgba(255,240,210,0.00)");
    sky.fillStyle = mg;
    sky.fillRect(0,0,S.w,S.h);

    for(const st of S.stars){
      const tw = 0.5 + 0.5*Math.sin(S.t*st.tw + st.ph);
      const a = clamp(st.a * (0.7 + 0.6*tw), 0, 1);
      sky.fillStyle = `rgba(255,255,255,${a})`;
      sky.beginPath();
      sky.arc(st.x, st.y, st.r * (0.85 + 0.25*tw), 0, Math.PI*2);
      sky.fill();
    }

    const hz = sky.createRadialGradient(S.w*0.55, S.h*0.38, S.h*0.10, S.w*0.55, S.h*0.38, S.h*0.75);
    hz.addColorStop(0.00, `rgba(255,255,255,${CFG.haze*0.22})`);
    hz.addColorStop(0.45, `rgba(255,255,255,${CFG.haze*0.10})`);
    hz.addColorStop(1.00, "rgba(255,255,255,0)");
    sky.fillStyle = hz;
    sky.fillRect(0,0,S.w,S.h);

    if(S.shooters.length){
      sky.globalCompositeOperation = "lighter";
      for(const sh of S.shooters){
        const p = clamp(sh.age / sh.life, 0, 1);
        const fade = (p < 0.2) ? (p/0.2) : (p > 0.85) ? (1 - (p-0.85)/0.15) : 1;
        const a = 0.85 * fade * sh.glow;

        const mag = Math.max(1, Math.hypot(sh.vx, sh.vy));
        const dx = sh.vx / mag, dy = sh.vy / mag;

        const x2 = sh.x - dx * sh.len;
        const y2 = sh.y - dy * sh.len;

        const grad = sky.createLinearGradient(sh.x, sh.y, x2, y2);
        grad.addColorStop(0.00, `rgba(255,255,255,${a})`);
        grad.addColorStop(0.25, `rgba(255,240,200,${a*0.55})`);
        grad.addColorStop(0.70, `rgba(180,220,255,${a*0.18})`);
        grad.addColorStop(1.00, "rgba(180,220,255,0)");

        sky.strokeStyle = grad;
        sky.lineWidth = 2.2 + 1.8*(1-p);
        sky.lineCap = "round";
        sky.beginPath();
        sky.moveTo(sh.x, sh.y);
        sky.lineTo(x2, y2);
        sky.stroke();

        const rg = sky.createRadialGradient(sh.x, sh.y, 0, sh.x, sh.y, 26);
        rg.addColorStop(0, `rgba(255,255,255,${a*0.55})`);
        rg.addColorStop(1, "rgba(255,255,255,0)");
        sky.fillStyle = rg;
        sky.beginPath();
        sky.arc(sh.x, sh.y, 26, 0, Math.PI*2);
        sky.fill();
      }
      sky.globalCompositeOperation = "source-over";
    }

    const vg = sky.createRadialGradient(S.w*0.5, S.h*0.45, S.h*0.20, S.w*0.5, S.h*0.45, S.h*0.95);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, `rgba(0,0,0,${CFG.vignette})`);
    sky.fillStyle = vg;
    sky.fillRect(0,0,S.w,S.h);
  }

  function drawSnowLayer(g, flakes, isFront){
    g.setTransform(S.dpr,0,0,S.dpr,0,0);
    g.clearRect(0,0,S.w,S.h);
    if(!S.snowOn) return;

    const driftX = Math.sin(S.t*0.12) * (isFront ? 2.0 : 1.2);
    const driftY = Math.cos(S.t*0.10) * (isFront ? 1.5 : 0.9);

    for(const f of flakes){

      // bokeh blobs
      if(f.idx !== undefined && f.vx !== undefined){
        const spr = S.sprites.bokeh[f.idx];
        const w = spr.width * f.s;
        const h = spr.height * f.s;
        const tw = 0.7 + 0.3*Math.sin(S.t*0.8 + f.ph);
        g.globalAlpha = clamp(f.a * tw, 0, 1);
        g.drawImage(spr, f.x - w/2 + driftX, f.y - h/2 + driftY, w, h);
        continue;
      }

      // crisp snowflake shape
      if(f.type === "flake"){
        const baseR = (isFront ? 11 : 8) * f.size;
        const x = f.x + driftX;
        const y = f.y + driftY;

        const tw = 0.9 + 0.1*Math.sin(S.t*1.6 + f.ph);
        const a = clamp(f.alpha * tw * f.sparkle, 0, 1);

        g.save();
        g.translate(x, y);
        g.rotate(f.spin * 0.25);

        g.lineCap = "round";
        g.lineJoin = "round";
        g.strokeStyle = "rgba(255,255,255,1)";

        // glow pass
        g.globalAlpha = a * 0.35;
        g.lineWidth = f.thick * (isFront ? 3.0 : 2.2);
        const arms = f.arms || 6;
        for(let i=0;i<arms;i++){
          const ang = (Math.PI*2*i)/arms;
          g.beginPath();
          g.moveTo(0,0);
          g.lineTo(Math.cos(ang)*baseR, Math.sin(ang)*baseR);
          g.stroke();
        }

        // sharp pass
        g.globalAlpha = a;
        g.lineWidth = f.thick * (isFront ? 1.5 : 1.15);

        for(let i=0;i<arms;i++){
          const ang = (Math.PI*2*i)/arms;
          const x2 = Math.cos(ang) * baseR;
          const y2 = Math.sin(ang) * baseR;

          g.beginPath();
          g.moveTo(0,0);
          g.lineTo(x2,y2);
          g.stroke();

          const branchR = baseR * 0.34;
          const bx = Math.cos(ang) * baseR * 0.64;
          const by = Math.sin(ang) * baseR * 0.64;

          const bAng1 = ang + Math.PI/6;
          const bAng2 = ang - Math.PI/6;

          g.beginPath();
          g.moveTo(bx,by);
          g.lineTo(bx + Math.cos(bAng1)*branchR, by + Math.sin(bAng1)*branchR);
          g.stroke();

          g.beginPath();
          g.moveTo(bx,by);
          g.lineTo(bx + Math.cos(bAng2)*branchR, by + Math.sin(bAng2)*branchR);
          g.stroke();
        }

        g.globalAlpha = a * 0.9;
        g.fillStyle = "rgba(255,255,255,0.9)";
        g.beginPath();
        g.arc(0,0, baseR*0.11, 0, Math.PI*2);
        g.fill();

        g.restore();
        continue;
      }

      // glow sprite
      const spr = S.sprites.snow[f.spriteIdx];
      const s = (isFront ? 0.70 : 0.62) * f.size;
      const w = spr.width * s;
      const h = spr.height * s;

      const tw = 0.9 + 0.1*Math.sin(S.t*1.6 + f.ph);
      g.globalAlpha = clamp(f.alpha * tw * f.sparkle, 0, 1);

      if(isFront && f.z > 0.78){
        g.save();
        g.translate(f.x + driftX, f.y + driftY);
        g.rotate(f.spin * 0.08);
        g.drawImage(spr, -w/2, -h/2, w, h);
        g.restore();
      }else{
        g.drawImage(spr, f.x - w/2 + driftX, f.y - h/2 + driftY, w, h);
      }
    }

    const fog = g.createLinearGradient(0, S.h*0.55, 0, S.h);
    fog.addColorStop(0.0, "rgba(255,255,255,0)");
    fog.addColorStop(1.0, isFront ? "rgba(255,255,255,0.06)" : "rgba(255,255,255,0.04)");
    g.globalAlpha = 1;
    g.fillStyle = fog;
    g.fillRect(0,0,S.w,S.h);
  }

  function tick(ts){
    if(!S.last) S.last = ts;
    const dt = Math.min(0.033, (ts - S.last)/1000);
    S.last = ts;

    S.t += dt;

    if((Math.floor(S.t*2) % 4) === 0) seedSnow(false);

    if(S.snowOn) stepSnow(dt);
    stepShooters(dt);

    drawSky();
    drawSnowLayer(back, S.flakesBack, false);
    drawSnowLayer(front, S.flakesFront, true);

    requestAnimationFrame(tick);
  }

  document.getElementById("snowBtn").addEventListener("click", ()=>{
    S.snowOn = !S.snowOn;
    document.getElementById("snowBtn").textContent = S.snowOn ? "Snow: ON ‚ùÑ" : "Snow: OFF";
  });

  scheduleNextShoot();
  resize();
  window.addEventListener("resize", resize);
  requestAnimationFrame(tick);
})();

/* =========================
   Audio controls
   ========================= */
const audioEl = document.getElementById("bgm");
const musicBtn = document.getElementById("musicBtn");
const vol = document.getElementById("vol");

function setVol(){ audioEl.volume = Number(vol.value) / 100; }
vol.addEventListener("input", setVol);
setVol();

musicBtn.addEventListener("click", async () => {
  if (audioEl.paused) {
    try{
      audioEl.load();
      await audioEl.play();
      musicBtn.textContent = "‚è∏ Pause music";
    }catch{
      musicBtn.textContent = "‚ñ∂ Play music";
    }
  } else {
    audioEl.pause();
    musicBtn.textContent = "‚ñ∂ Play music";
  }
});
  </script>
</body>
</html>
